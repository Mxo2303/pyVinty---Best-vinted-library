# pyVinty - Public Functions

Stateless with a stateful session client
This document exposes **exactly** all the public functions usable from pyVinty, their parameters, and the returned data.

## Table of Contents

1. [CloudScraper Session Configuration](#cloudscraper-session-configuration)
2. [Utility Functions (tokens.py)](#utility-functions-tokenspy)
3. [Services](#services)
   - [MessagingService](#messagingservice)
   - [PaymentService](#paymentservice)
   - [NotificationService](#notificationservice)
   - [AuthService](#authservice)
4. [SessionManager](#sessionmanager)
5. [DataDomeHelper](#datadomehelper)

---

## CloudScraper Session Configuration

Before using pyVinty, you need to configure a session with CloudScraper.

### Basic Configuration

```python
import asyncio
from pyvinty import (
    VintedClient, VintedDomain, 
    refresh_tokens, get_public_session,
    DataDomeHelper
)

async def setup_session():
    # 1. User agent REQUIRED
    user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36"
    
    # 2. Initialize client
    client = VintedClient(user_agent=user_agent, domain=VintedDomain.FRANCE)
    
    # 3. Get fresh DataDome cookie
    datadome_cookie = await DataDomeHelper.get_fresh_cookie(target_url="https://www.vinted.fr", auto_close=True)
    if datadome_cookie:
        client.set_cookies({"datadome": datadome_cookie['value']})
    
    # 4. Get public session cookies
    public_cookies = await get_public_session(client.config)
    client.set_cookies(public_cookies)
    
    # 5. For authenticated operations, refresh tokens
    refresh_token = "your_refresh_token_here"
    updated_cookies = await refresh_tokens(client, refresh_token)
    client.set_cookies(updated_cookies)
    
    return client

# Usage
client = await setup_session()
```

### **IMPORTANT: Cookies/Tokens Management**

**Vinted user cookies and tokens are automatically managed by the pyVinty client.**

- **No need** to pass cookies as parameters to each method
- **The client stores** all necessary cookies automatically
- **All methods** automatically use the client's cookies
- **Single configuration** at the beginning with `client.set_cookies()`

```python
# INCORRECT - No need to pass cookies
# result = await client.messaging.get_conversations(cookies=my_cookies)

# CORRECT - Cookies are automatically used
result = await client.messaging.get_conversations()
```

### Types of Cookies Automatically Managed

1. **Public session cookies** - Via `get_public_session()`
2. **Authentication cookies** - Via `refresh_tokens()`  
3. **DataDome cookie** - Via `DataDomeHelper.get_fresh_cookie()`
4. **Navigation cookies** - Automatically generated by requests

**Once configured with `client.set_cookies()`, all method calls automatically use these cookies.**

### **DataDome: Manual vs Automatic**

**DataDomeHelper is primarily MANUAL:**

- **Not automatic** in services (except specific case)
- **User must** call `DataDomeHelper.get_fresh_cookie()` manually
- **Single exception**: AuthService with `interactive_captcha=True`

```python
# DataDome is NOT managed automatically
result = await client.messaging.get_conversations()  # No auto DataDome

# User must configure DataDome manually
dd_cookie = await DataDomeHelper.get_fresh_cookie(target_url="https://www.vinted.fr")
if dd_cookie:
    client.set_cookies({"datadome": dd_cookie['value']})

# Exception: AuthService can handle DataDome automatically
auth_result = await client.auth.authenticate("user", "pass", interactive_captcha=True)
```

### Important Points
- **User agent required**: Without user agent, requests will fail
- **DataDome MANUAL**: Must be configured by user (except AuthService)
- **Public session**: Required for certain operations
- **Authenticated tokens**: Required for private user operations

---

## Utility Functions (tokens.py)

### `refresh_tokens(client, refresh_token)`

Refreshes user authentication tokens.

**Parameters:**
- `client` (VintedClient): Configured client instance
- `refresh_token` (str): Refresh token obtained during authentication

**Returns:**
- `Dict[str, str]`: Dictionary of updated cookies

**Usage:**
```python
updated_cookies = await refresh_tokens(client, "eyJraWQiOiJFNTdZZH...")
client.set_cookies(updated_cookies)
```

**Important:**
- Must be called regularly to maintain authentication
- The refresh_token must be valid and not expired
- Returned cookies must be applied to the client

### `get_public_session(config)`

Gets an unauthenticated public session.

**Parameters:**
- `config` (VintedConfig): Client configuration (via client.config)

**Returns:**
- `Dict[str, str]`: Dictionary of public session cookies

**Usage:**
```python
public_cookies = await get_public_session(client.config)
client.set_cookies(public_cookies)
```

---

## Services

### **Automatic Authentication of Services**

**All services automatically use the configured client authentication:**

- **No cookie/token parameters** needed in methods
- **Configure once** with `client.set_cookies()`
- **Transparent management** of authentication

```python
# Initial configuration (once only)
client = VintedClient(user_agent="...", domain=VintedDomain.FRANCE)
updated_cookies = await refresh_tokens(client, refresh_token)
client.set_cookies(updated_cookies)

# All methods automatically use authentication
conversations = await client.messaging.get_conversations()
notifications = await client.notifications.get_favorite_notifications()
balance = await client.payments.get_user_balance(user_id)
# No need to pass cookies to each call!
```

---

## MessagingService

Access: `client.messaging`

### `get_conversations(page=1, per_page=20)`

Retrieves the list of conversations with preprocessed data.

**Parameters:**
- `page` (int, optional): Page number (default: 1)
- `per_page` (int, optional): Items per page (default: 20)

**Returns:**
```python
{
    "conversations": [
        {
            "id": int,                   # Conversation ID
            "login": str,                # Other user's login  
            "last_message": str,         # Last message
            "updated_at": str,           # Last activity timestamp
            "item_count": int,           # Number of items
            "read": bool,                # Read status
            "unread": bool,              # Inverse of read
            "raw_data": dict             # Raw API data
        }
    ],
    "pagination": {
        "current_page": int,
        "total_pages": int,
        "total_count": int,
        "per_page": int
    },
    "raw_response": dict                 # Complete API response
}
```

**Usage:**
```python
conversations = await client.messaging.get_conversations(page=1, per_page=10)
for conv in conversations["conversations"]:
    print(f"Conversation with {conv['login']}: {conv['last_message']}")
```

### `get_conversation_details(conversation_id)`

Retrieves conversation details with preprocessed messages.

**Parameters:**
- `conversation_id` (int): Conversation ID

**Returns:**
```python
{
    "conversation": {
        "id": int,
        "other_user_login": str,         # Other user's login
        "item_count": int,
        "raw_data": dict
    },
    "messages": [
        {
            "id": int,                   # Message ID
            "body": str,                 # Message content
            "created_at": str,           # Creation timestamp
            "sender_login": str,         # Sender login
            "is_from_current_user": bool,# Message from current user
            "entity_type": str,          # Message type
            "raw_data": dict
        }
    ],
    "raw_response": dict
}
```

**Usage:**
```python
details = await client.messaging.get_conversation_details(12345)
for message in details["messages"]:
    sender = "Me" if message["is_from_current_user"] else message["sender_login"]
    print(f"{sender}: {message['body']}")
```

### `send_message(conversation_id, message, photo_ids=None)`

Sends a message in a conversation.

**Parameters:**
- `conversation_id` (int): Conversation ID
- `message` (str): Message content
- `photo_ids` (List[int], optional): Photo IDs to attach

**Returns:**
- `Dict[str, Any]`: API response of sent message

**Usage:**
```python
response = await client.messaging.send_message(12345, "Hello!")
# With photos
response = await client.messaging.send_message(12345, "Here are photos", photo_ids=[1001, 1002])
```

### `accept_offer(transaction_id, offer_request_id)`

Accepts a price offer.

**Parameters:**
- `transaction_id` (int): Transaction ID
- `offer_request_id` (int): Offer request ID

**Returns:**
- `Dict[str, Any]`: API response of acceptance

### `reject_offer(transaction_id, offer_request_id)`

Rejects a price offer.

**Parameters:**
- `transaction_id` (int): Transaction ID
- `offer_request_id` (int): Offer request ID

**Returns:**
- `Dict[str, Any]`: API response of rejection

### `make_offer(conversation_id, amount)`

Makes a price offer on an item.

**Parameters:**
- `conversation_id` (int): Conversation ID
- `amount` (float): Offer amount

**Returns:**
- `Dict[str, Any]`: API response of the offer

### `find_pending_offers(conversation_details)`

Finds pending offers in a conversation.

**Parameters:**
- `conversation_details` (dict): Conversation details (from get_conversation_details())

**Returns:**
- `List[Dict[str, Any]]`: List of pending offers

### `get_conversations_list(page=1, per_page=10, current_user_id=None)`

**ALTERNATIVE METHOD** - Returns a structured ConversationsResponse object.

**Parameters:**
- `page` (int): Page number
- `per_page` (int): Items per page
- `current_user_id` (int, optional): Current user ID (auto-detected if None)

**Returns:**
- `ConversationsResponse`: Object with structured conversations and pagination

### `get_conversation_messages_list(conversation_id, current_user_id=None)`

**ALTERNATIVE METHOD** - Returns a structured MessagesResponse object.

**Parameters:**
- `conversation_id` (int): Conversation ID
- `current_user_id` (int, optional): Current user ID (auto-detected if None)

**Returns:**
- `MessagesResponse`: Object with structured messages and metadata

---

## PaymentService

Access: `client.payments`

### `create_transaction(item_id, seller_id)`

Creates a purchase transaction with preprocessed data.

**Parameters:**
- `item_id` (int): Item ID to purchase
- `seller_id` (int): Seller ID

**Returns:**
```python
{
    "transaction": {
        "item_id": int,              # Item ID
        "item_title": str,           # Item title
        "item_url": str,             # Item URL
        "conversation_id": int       # Created conversation ID
    },
    "pricing": {
        "item_price": {
            "amount": float,         # Item price
            "currency": str          # Currency (EUR, USD...)
        },
        "service_fee": {
            "amount": float,         # Service fee
            "currency": str
        },
        "total": {
            "amount": float,         # Total price
            "currency": str
        }
    },
    "shipping_options": {
        "pickup_points": [],         # Available pickup points
        "home_delivery": [],         # Home delivery options
        "selected_option": dict      # Selected option
    },
    "payment_methods": {
        "available_cards": [],       # Available cards
        "balance_available": bool,   # Vinted balance available
        "selected_payment_method": dict
    },
    # Compatibility fields
    "transaction_id": int,
    "checkout_id": str,
    "shipping_id": str,
    "conversation_id": int,
    "photo_url": str,
    "title": str
}
```

**Usage:**
```python
transaction = await client.payments.create_transaction(item_id=123456, seller_id=789)
print(f"Item: {transaction['transaction']['item_title']}")
print(f"Price: {transaction['pricing']['total']['amount']} {transaction['pricing']['total']['currency']}")
```

### `get_coordinates_from_address(address)`

Geocodes an address to obtain GPS coordinates.

**Parameters:**
- `address` (Dict[str, Any]): Address dictionary with the following fields:
  - `line1` (str): First address line (number + street)
  - `postal_code` (str): Postal code
  - `city` (str): City
  - `country_iso_code` (str): Country code (FR, BE, etc.)

**Returns:**
```python
# Success
{
    "latitude": float,               # GPS latitude
    "longitude": float               # GPS longitude
}

# Failure
None
```

**Usage:**
```python
address = {
    "line1": "123 rue de la Paix",
    "postal_code": "75001",
    "city": "Paris", 
    "country_iso_code": "FR"
}

coords = await client.payments.get_coordinates_from_address(address)
if coords:
    print(f"Coordinates: {coords['latitude']}, {coords['longitude']}")
    # Use for select_delivery_method with shipping_method=1
    delivery = await client.payments.select_delivery_method(
        transaction_data, 
        shipping_method=1, 
        latitude=coords['latitude'], 
        longitude=coords['longitude']
    )
else:
    print("Geocoding failed - address not found")
```

**Important information:**
- 15-second timeout per request
- Returns `None` if address is not found or in case of error
- Primarily used to find nearby pickup points
- Coordinates can then be used with `select_delivery_method()`

### `select_delivery_method(transaction_data, shipping_method, latitude=None, longitude=None)`

Selects delivery method with preprocessed data.

**Parameters:**
- `transaction_data` (dict): Transaction data from create_transaction()
- `shipping_method` (int): 1 for pickup point, 2 for home delivery
- `latitude` (float, optional): Latitude (required for pickup point)
- `longitude` (float, optional): Longitude (required for pickup point)

**Returns:**
```python
{
    "delivery_info": str,           # Description of chosen delivery
    "checksum": str,                # Checksum for next step
    "pricing": {                    # Updated pricing with delivery
        "item_price": {...},
        "service_fee": {...},
        "total": {...}
    },
    "shipping_options": {...},      # Updated shipping options
    "payment_methods": {...},       # Updated payment methods
    "checkout_id": str,
    "shipping_method": int,
    "price": str                    # Legacy format "amount currency"
}
```

### `prepare_payment(checkout_id, payment_method, card_id=None)`

Prepares the payment method.

**Parameters:**
- `checkout_id` (str): Checkout ID
- `payment_method` (int): 1 for card, 2 for Vinted balance
- `card_id` (int, optional): Card ID (required if payment_method=1)

**Returns:**
- `str`: New checksum to finalize payment

### `complete_payment(checkout_id, checksum)`

Finalizes payment with preprocessed data.

**Parameters:**
- `checkout_id` (str): Checkout ID
- `checksum` (str): Checksum from prepare_payment()

**Returns:**
```python
{
    "status": str,                   # "success", "pending", "failed"
    "transaction_id": str,           # Transaction ID
    "redirect_url": str,             # 3D Secure URL if needed
    "requires_action": bool          # True if user action required
}
```

**Usage:**
```python
result = await client.payments.complete_payment(checkout_id, checksum)
if result["status"] == "success":
    print("Payment successful!")
elif result["requires_action"]:
    print(f"3D Secure required: {result['redirect_url']}")
```

### Other PaymentService methods

- `get_user_balance(user_id)`: Gets Vinted balance
- `get_coordinates_from_address(address)`: Geocodes an address
- `get_current_user()`: User information (delegated to SessionManager)

---

## NotificationService

Access: `client.notifications`

### `get_notifications(page=1, per_page=20)`

Retrieves notifications with preprocessed data.

**Parameters:**
- `page` (int, optional): Page number (default: 1)
- `per_page` (int, optional): Items per page (default: 20)

**Returns:**
```python
{
    "notifications": [
        {
            "id": int,                   # Notification ID
            "entry_type": int,           # Notification type
            "timestamp": str,            # Date/time
            "read_status": bool,         # Read status
            "body": str,                 # Notification content
            "photo_url": str,            # Associated photo URL
            "raw_data": dict             # Raw API data
        }
    ],
    "pagination": {
        "current_page": int,
        "per_page": int, 
        "total_count": int,
        "total_pages": int,
        "has_next_page": bool
    },
    "raw_response": dict
}
```

### `get_favorite_notifications(page=1, per_page=20)`

Retrieves only favorite notifications with automatic parsing.

**Parameters:**
- `page` (int, optional): Page number (default: 1) 
- `per_page` (int, optional): Items per page (default: 20)

**Returns:**
```python
[
    {
        "timestamp": str,            # Date/time
        "username": str,             # User who favorited
        "item_name": str,            # Item name
        "photo_url": str,            # Item photo URL
        "body": str,                 # Complete message
        "read_status": bool,         # Read status
        "parsed_successfully": bool, # True if parsing succeeded
        "raw_data": dict             # Raw data
    }
]
```

**Usage:**
```python
favorites = await client.notifications.get_favorite_notifications()
for fav in favorites:
    print(f"{fav['username']} liked '{fav['item_name']}'")
```

### `get_notification_types(page=1, per_page=20)`

Groups notifications by type.

**Returns:**
```python
{
    20: [notifications],             # Type 20 = favorites
    15: [notifications],             # Type 15 = messages
    # ... other types
}
```

### `get_unread_count()`

Counts unread notifications.

**Returns:**
```python
{
    "unread_count": int,             # Number unread
    "total_count": int,              # Total notifications
    "checked_count": int,            # Checked notifications
    "pagination": {...}              # Pagination info
}
```

### Other NotificationService methods

- `mark_notification_as_read(notification_id)`: Mark as read
- `mark_all_notifications_as_read()`: Mark all as read

---

## AuthService

Access: `client.auth`

### `login(email, password)`

Authentication by email/password.

**Parameters:**
- `email` (str): Email address
- `password` (str): Password

**Returns:**
- `Dict[str, Any]`: Authentication response with tokens

### `verify_2fa(code, login_response)`

Verifies 2FA code.

**Parameters:**
- `code` (str): 2FA code received
- `login_response` (dict): Response from login()

**Returns:**
- `Dict[str, Any]`: Finalized authentication tokens

### `authenticate(username, password, interactive_captcha=False)`

Authenticates a user with username and password.

**Parameters:**
- `username: str` - Vinted username/email
- `password: str` - User password
- `interactive_captcha: bool = False` - Automatic DataDome challenge handling

**Usage:**
```python
from pyvinty.services.auth import AuthService

auth_service = AuthService(http_client, session_manager)
result = await auth_service.authenticate("your_username", "your_password")

# With interactive captcha handling
result = await auth_service.authenticate("user", "pass", interactive_captcha=True)
```

**Returns:**
```python
{
    "status": "success_no_2fa" | "requires_2fa" | "failed",
    "response_body": {...},  # Complete response data
    "cookies": {...},        # Session cookies
    "message": "...",        # Error message if failure
    "control_code": "...",   # Control code if 2FA required
    "raw_body": {...}        # Raw response on error
}
```

### `complete_2fa(username, control_code, verification_code, initial_cookies)`

Completes two-factor authentication.

**Parameters:**
- `username: str` - Vinted username/email
- `control_code: str` - Control code from initial authentication
- `verification_code: str` - User's 2FA verification code
- `initial_cookies: Dict[str, str]` - Cookies from initial authentication

**Usage:**
```python
# After receiving "requires_2fa" during initial authentication
result = await auth_service.complete_2fa(
    username="your_username",
    control_code=auth_result["control_code"],
    verification_code="123456",  # Code received via SMS/email
    initial_cookies=auth_result["cookies"]
)
```

**Returns:**
```python
{
    "status": "success" | "failed",
    "response_body": {...},  # Complete response data
    "cookies": {...},        # Final session cookies
    "message": "...",        # Error message if failure
    "raw_body": {...}        # Raw response on error
}
```

---

## SessionManager

Access: `client.session_manager`

### `get_current_user_raw()`

Retrieves raw user information.

**Returns:**
- `Dict[str, Any]`: Raw API response

### `get_current_user_info()`

Retrieves user information in a structured VintedUser object.

**Returns:**
```python
VintedUser(
    id=int,                          # User ID
    login=str,                       # Username
    real_name=Optional[str],         # Real name
    email=Optional[str],             # Email
    anon_id=Optional[str],           # Anonymous ID
    birthday=Optional[str],          # Birth date
    gender=Optional[str],            # Gender
    city=Optional[str],              # City
    country_code=Optional[str],      # Country code
    currency=Optional[str],          # Currency
    item_count=int,                  # Number of items
    followers_count=int,             # Number of followers
    following_count=int,             # Number following
    is_online=bool,                  # Online status
    evaluations=VintedUserEvaluations, # Evaluations
    address=VintedUserAddress,       # Address
    photo=VintedUserPhoto            # Profile photo
)
```

---

## DataDomeHelper

### **Usage: MANUAL by default**

**DataDomeHelper is NOT automatic in services - users must use it manually.**

### `get_fresh_cookie(target_url="https://www.vinted.fr", auto_close=True)`

Generates a fresh DataDome cookie to avoid anti-bot blocking.

**Parameters:**
- `target_url` (str, optional): Target Vinted URL (default: "https://www.vinted.fr")
- `auto_close` (bool, optional): Auto-close browser (default: True)

**Returns:**
```python
{
    "name": "datadome",
    "value": str,                    # DataDome cookie value
    "domain": str,                   # Domain (.vinted.fr)
    "path": str                      # Path (/)
}
# Or None if failed
```

**Typical usage:**
```python
# 1. Manual retrieval before sensitive operations
dd_cookie = await DataDomeHelper.get_fresh_cookie(target_url="https://www.vinted.fr")
if dd_cookie:
    client.set_cookies({"datadome": dd_cookie['value']})
    print(f"DataDome configured: {dd_cookie['value'][:30]}...")

# 2. Services then automatically use this cookie
conversations = await client.messaging.get_conversations()  # Uses configured DataDome
payments = await client.payments.get_user_balance(user_id)  # Same
```

### **Automatic usage case**

**Only exception: AuthService with `interactive_captcha=True`**

```python
# DataDome handled automatically by AuthService if challenge detected
auth_result = await client.auth.authenticate(
    username="user", 
    password="pass", 
    interactive_captcha=True
)
```

### **Recommendations**

1. **Configure DataDome** before sensitive operations (auth, payments, messages...)
2. **Reuse the same cookie** for the entire session
3. **Refresh periodically** if frequent blocking occurs
4. **Monitor logs** to detect DataDome challenges

---

## Important Notes

### Error Handling

All methods can raise exceptions:
- `APIError`: Vinted API error
- `AuthenticationError`: Authentication problem
- `VintedError`: General pyVinty error

### Async Management

All methods are asynchronous and must be called with `await`:
```python
async def main():
    client = VintedClient(...)
    result = await client.messaging.get_conversations()
    await client.close()

asyncio.run(main())
```

### Important Information

- Authentication follows a 2-step process if 2FA is enabled
- Returned cookies must be used for subsequent sessions
- Automatic DataDome challenge handling with `interactive_captcha=True`
- All errors are logged with complete details
- Methods use data preprocessing architecture

The `raw_data` and `raw_response` fields are available in all responses.
